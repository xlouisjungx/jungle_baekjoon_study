------------------------------------------------------------
# jungle_study
------------------------------------------------------------
### 1주차 공부 README
* 교재에 대한 공부와 공부 키워드에 따른 공부를 작성합니다.
------------------------------------------------------------
## 1주차 범위: ~1.4 프로세서는 메모리에 저장된 인스트럭션을 읽고 해석한다.

### 책읽기
* 1.1 정보는 비트와 컨텍스트로 이루어진다

    - 정보는 비트와 컨텍스트로 이루어진다.

    - 대부분 텍스트 문자를 아스키(ASCII) 표준을 사용 -> 각 바이트는 특정 문자에 대응 되는 정수값을 갖는다. ex) 35 = #, \n도 정수 값 10으로 표시된다.

    - 텍스트 파일: 오로지 아스키 문자들로만 이루어진 파일들

    - 파이너리 파일: 다른 모든 파일들

    - 시스템 내부의 정보 - 디스크 파일, 메모리상의 프로그램, 데이터, 네트워크를 통해 전송되는 데이터 - -> 비트들로 표시

* 1.2 프로그램은 다른 프로그램에 의해 다른 형태로 번역된다

    - 각 C 문장들은 다른 프로그램들에 의해 저급 기계어 인스트럭션들로 번역되어야 하는데, 이 인스트럭션들이 [실행가능 목적 프로그램] or [실행가능 목적 파일]의 형태로 합쳐져 [바이너리 디스크 파일]로 저장된다.

    - 컴파일 시스템 : [전처리기, 컴파일러, 어셈블러, 링커]

    - 전처리 단계
        - 본래의 C 프로그램 --> .i로 끝나는 새로운 C 프로그램이 생성 // 어떤 일을 하라고 지시하는 것. 

    - 컴파일 단계
        - 텍스트 파일 파일명.i --> 텍스트파일 파일명.s로 번역 // 어셈블리어 프로그램 저장
        - *어셈블리어: 여러 상위수준 언어의 컴파일러들을 위한 공통의 출력언어를 제공하기 떄문에 유용하다. ex) C, Fortran

    - 어셈블리 단계
        - 어셈블러가
        - [1] 파일명.s를 기계어 인스트러셔으로 번역함.
        - [2] 재배치가능 목적프로그램의 형태로 묶어서,
        - [3] 파일명.o라는 목적파일에 그 결과를 저장함.
            - --> 이 파일은 main 함수의 인스트럭션들을 인코딩하기 위한 17바이트를 포함하는 바이너리 파일이다. 

    - 링크 단계
        - 우리가 C에서 흔히 쓰는 printf는 C 라이브러리에 들어있는 printf 함수를 호출하여 사용되는 것이다.  이 printf 함수는 이미 컴파일된 별도의 목적파일인 printf.o가 들어 있으며, 어떤 파일이랑 어떤 형태로든 결합이 되어야하는데, 이를 링커 프로그램이 이 통합작업을 수행한다.
        - --> [파일명] 파일은 실행가능 목적파일(실행파일)로 메모리에 적재되어 시스템에 이해 실행된다.  

* 1.3 컴파일 시스템이 어떻게 동작하는지 이해하는 것은 중요하다

    - 어떻게 컴파일 시스템이 동작하는지 이해해야 하는 중요한 이유가 있다.
        - 프로그램 성능 최적화하기
        - 링크 에러 이해하기
        - 보안 약점 피하기
            - 오버플로우 취약성이 보안 약점의 주요 원인.
            - 프로그램 스택에 데이터와 제어 정보가 저장되는 방식 때문에 생겨나는 영향을 이해 하는 것.

* 1.4 프로세서는 메모리에 저장된 인스트럭션을 읽고 해석한다
    - 1.4.1 시스템의 하드웨어 조직
    - 1.4.2 hello 프로그램의 실행
------------------------------------------------------------
## 1주차 범위: 배열, 문자열, 반복문과 재귀 함수, 복잡도(BigO,시간,공간), 정렬, 완전 탐색, 정수론

### 공부 키워드
* 배열
    - 파이썬의 경우, 배열을 리스트(list)와 튜플(tuple)로 구현할 수 있다.
   
    - 리스트는 원소를 변경할 수 있는 뮤터블 list형 객체이다.
        - list = [] --> [] 빈 리스트 
        - list = [1, 2, 3] --> [1, 2, 3]
        - list = ['A', 'B', 'C', ] --> ['A', 'B', 'C']
   
    - 튜플
        - 원소에 순서를 매겨 결한합 것으로 원소를 변경할 수 없는 이뮤터블 자료형이다. // () 생략 가능

    - 리스트나 튜플의 원소에 접글할 떄는 인덱스를 사용한다. 

    - 슬라이스: 리스트 또는 튜플의 원소 일부를 연속해서 또는 일정한 간격으로 꺼내 새로운 리스트 또는 튜플을 만드는 것.
        - ex) s[i:j] --> s[i]부터 s[j-1]까지 나열
        - ex) s[i:j:k] --> s[i]부터 s[j-1]까지 k씩 건너뛰며 나열

    - ** 변수에 어떤  겂을 대입하면 값이 아니라, 식별 번호가 바뀐다."

    - [Practice/ListTest.py](/PracticePy/ListTest.py)

* 문자열
    - 문자열 인덱스
        - 문자열이름 = 'abc' // 문자 각자가 번호를 가지고 있는데, 번호는 0번부터 시작하여 측정한다. 
        - -3,-2, -1 // 0, 1, 2
        
    - 문자열 슬라이스
        - 문자열[2:5] --> 2번부터 4번까지의 문자를 가짐
        - 문자열[-5:-1] --> -5번부터 -2번까지의 문자를 가짐
        - 문자열[5:] --> 5번부터 끝까지 가져옴
        - 문자열[:5] --> 0번부터 4번까지 가져옴
        - 문자열[:] --> 처음부터 끝까지 가져옴
        - 문자열[2:5:?] -> 2번부터 4번까지 ?씩 건너뛰어 가져옴 // ?가 음수일떄, 거꾸로 가져옴 + 한칸 더 내려갈 수 있도록 해야함
        - 문자열[::-1] --> 처음부터 끝까지 문자열 뒤집어서 가져옴

    - 문자열 메소드
        - 1. 출력 지정: format(a,b,c,...)
            - 넣고 싶은것을 대체하여 넣을 수 있게 해줌

        - 2. 대체하기: replace(a,b)
            - replace(내가 바꾸고 싶은 대상, 바꾸고 싶은 값)

        - 3. 자르기: split(a)
            - split(자르고자 하는 구분자)

        - 4. 합치기: a.join()
            - 문자와 문자를 합칠떄 / 리스트에 있는것들을 합칠 떄 사용
            - 합칠문자.join(합칠문자)
        
        - 5. 개수 확인하기: count(a)
            - count(전체 문자열에서 몇개가 있는지 확인하고 싶은 값)

        - 6. 제거하기: strip(a) / lstrip(a) / rstrip(a)
            - strip(거슬려서 제거하고 싶은거) // l+ 이면 왼쪽, r+ 이면 오른쪽 --> 중간값은 제거 못함

        - 7. 인덱스 찾기: find(a) / rfind(a) / index(a) / rindex(a)
            - (왼쪽에서 내가 찾는 값을 찾아줌) // 기본이 왼쪽부터, r+ 오른쪽 // {index - 왼쪽부터, rindex - 오른쪽부터} --> 없는 것을 찾으라고 할때, 에러가 남. (find는 -1값이 나옴)

        - 8. 확인하기: isalpha() / isdigit() / isalnum() / isupper() / islower
            - 반환을 True / False로 함
            - isalpha() : 알파벳으로만 이루어져있는가
            - isdigit() : 숫자로만 이루어져있는가
            - isalnum() : 숫자와 알파벳의 조합으로 이루어져있는가
            - isupper() : 대문자로 이루어져있는가
            - islower() : 소문자로 이루어져있는가

        - 9. 대 / 소문자 만들기 : upper() / lower()
            - upper() : 대문자로 바꾸어라
            - lower() : 소문자로 바꾸어라

        - 10. 0 채우기 : zfill()
            - 항상 0이 출력되어야 할 때, 부족한 부분에 필요한 만큼 채워줌
            

    - [PracticePy/StringsTest.py](PracticePy/StringsTest.py)

* 반복문과 재귀 함수
    - 반복문
        - for 문
        - while 문

        - [PracticePy/LoopAndReTest.py](PracticePy/LoopAndReTest.py)

    - 재귀 함수
        - 자기 자신을 부르는 함수(함수내에서 자기자신을 사용하는 함수)
        - 큰 문제를 풀기 위해 작은 문제의 답을 사용해야할 때 사용됨

* 복잡도(BigO,시간,공간) : 알고리즘의 효율성을 나타내는 지표
    - 시간 복잡도: 실행에 걸리는 시간
    - 공간 복잡도: 사용되는 메모리 크기
    - 빅오 표기법 (Dig-O Notation)
        - O(1) -> 상수 시간 (ex: 인덱스로 접근)
        - O(log N) -> 로그 시간 (ex: 이진 탐색)
        - O(N) -> 선형 시간 (ex: 리스트 순회)
        - O(N^2) -> 제곱 시간 (ex: 이중 반복문)
        - O(2^N) -> 지수 시간 (ex: 피보나치 재귀)

* 정렬
    - 선택 정렬: 전체에서 최소값을 찾고, 맨앞과 자리를 바꾼다. 이를 반복한다.
        - 시간 복잡도: O(N²) (모든 요소를 두 번씩 비교하기 때문)
            
    - 버블 정렬: 앞에서부터 인접한 두 값씩 비교하며, 더 큰값을 뒤로 보낸다.
        - 시간 복잡도: O(N²) (모든 요소를 계속 비교하기 때문)

    - 셀 정렬: 단순 삽입 정렬의 장점을 살리면서 단점을 보완한 것.
        - 1. 먼저 정렬한 배열의 원소를 그룹으로 나워 각 그룹별로 정렬을 수행한다.
        - 2. 정렬된 그룹을 합치는 작업을 반복하여 원소의 이동 횟수를 줄이는 방법이다.
        - 시간 복잡도: O(N log N) (최적의 경우)

* 완전 탐색
    - 가능한 모든 경우의 수를 다 탐색하며 정답을 찾는 방법
    - 시간 복잡도: O(N!) 또는 O(2^N)일 때도 많아.

* 정수론 : 숫자들의 관계와 속성을 다루는 수학 분야. 프로그래밍에서는 주로 최대공약수, 최소공배수, 소수 판별 등
    - 최대공약수 (GCD)
    - 최소공배수 (LCM)
    - 소수 판별 (Prime Check)
------------------------------------------------------------