------------------------------------------------------------
# jungle_study
------------------------------------------------------------
### 1주차 공부 README
* 교재에 대한 공부와 공부 키워드에 따른 공부를 작성합니다.
------------------------------------------------------------
## 1주차 범위: ~1.4 프로세서는 메모리에 저장된 인스트럭션을 읽고 해석한다.

### 책읽기
* 1.1 정보는 비트와 컨텍스트로 이루어진다

    - 정보는 비트와 컨텍스트(그 데이터를 어떻게 해석할지 결정하는 요소)로 이루어진다.

    - 대부분 텍스트 문자를 아스키(ASCII) 표준을 사용 -> 각 바이트는 특정 문자에 대응 되는 정수값을 갖는다. ex) 35 = #, \n도 정수 값 10으로 표시된다.

    - 텍스트 파일: 오로지 아스키 문자들로만 이루어진 파일들

    - 파이너리 파일: 다른 모든 파일들

    - 시스템 내부의 정보 - 디스크 파일, 메모리상의 프로그램, 데이터, 네트워크를 통해 전송되는 데이터 - -> 비트들로 표시

    - * 메모리 계층 구조

        - 메인 메모리(DRAM) 외에도 CPU 안에는 캐시 메모리(L1, L2, L3)가 있음.
        - 캐시는 CPU 속도를 따라가지 못하는 메인 메모리 접근 지연을 줄이기 위해 사용됨.
        - 프로그램 성능 최적화에서 캐시 친화적인 코드를 짜는 게 중요. (예: 배열 순회를 할 때 메모리 접근 패턴을 최적화) *

* 1.2 프로그램은 다른 프로그램에 의해 다른 형태로 번역된다

    - 각 C 문장들은 다른 프로그램들에 의해 저급 기계어 인스트럭션들로 번역되어야 하는데, 이 인스트럭션들이 [실행가능 목적 프로그램] or [실행가능 목적 파일]의 형태로 합쳐져 [바이너리 디스크 파일]로 저장된다.

    - 컴파일 시스템 : [전처리기, 컴파일러, 어셈블러, 링커]

    - 전처리 단계
        - 본래의 C 프로그램 --> .i로 끝나는 새로운 C 프로그램이 생성 // 어떤 일을 하라고 지시하는 것. 

    - 컴파일 단계
        - 텍스트 파일 파일명.i --> 텍스트파일 파일명.s로 번역 // 어셈블리어 프로그램 저장
        - *어셈블리어: 여러 상위수준 언어의 컴파일러들을 위한 공통의 출력언어를 제공하기 떄문에 유용하다. ex) C, Fortran

    - 어셈블리 단계
        - 어셈블러가
        - [1] 파일명.s를 기계어 인스트러셔으로 번역함.
        - [2] 재배치가능 목적프로그램의 형태로 묶어서,
        - [3] 파일명.o라는 목적파일에 그 결과를 저장함.
            - --> 이 파일은 main 함수의 인스트럭션들을 인코딩하기 위한 17바이트를 포함하는 바이너리 파일이다. 

    - 링크 단계
        - 우리가 C에서 흔히 쓰는 printf는 C 라이브러리에 들어있는 printf 함수를 호출하여 사용되는 것이다.  이 printf 함수는 이미 컴파일된 별도의 목적파일인 printf.o가 들어 있으며, 어떤 파일이랑 어떤 형태로든 결합이 되어야하는데, 이를 링커 프로그램이 이 통합작업을 수행한다.
        - --> [파일명] 파일은 실행가능 목적파일(실행파일)로 메모리에 적재되어 시스템에 이해 실행된다.  

        - *정적 링크(Static Linking): 모든 라이브러리 코드를 실행 파일에 포함시켜서 배포가 쉽지만 파일 크기가 커짐*
        - *동적링크(Dynamic Linking): 라이브러리 코드를 따로 두고, 프로그램이 실행될 떄 시스템이 라이브러리르 로드함. 이는 더 작고 유연하지만, 실행 환경에 따라 문제가 생길 수 있음.*

* 1.3 컴파일 시스템이 어떻게 동작하는지 이해하는 것은 중요하다

    - 어떻게 컴파일 시스템이 동작하는지 이해해야 하는 중요한 이유가 있다.
        - 프로그램 성능 최적화하기
        - 링크 에러 이해하기
        - 보안 약점 피하기
            - 오버플로우 취약성이 보안 약점의 주요 원인.
            - 프로그램 스택에 데이터와 제어 정보가 저장되는 방식 때문에 생겨나는 영향을 이해 하는 것.

* 1.4 프로세서는 메모리에 저장된 인스트럭션을 읽고 해석한다

    - *프로세서 파이프라이닝과 병렬성: CPU는 파이프라이닝이라는 기법을 통해 여러 인스트럭션을 겹쳐서 실행.
        - 한 인스트럭션이 메모리 접근을 수행하는 동안, 다른 인스트럭션이 연산을 수행하도록 설계돼 있다함.
        - 파이프라이닝(Pipelining)은 CPU가 인스트럭션(명령어)을 처리할 때, 여러 단계를 겹쳐서 동시에 처리하는 기법 ex) 공장 조립 라인
            - Fetch (가져오기): 메모리에서 명령어를 가져온다.
            - Decode (해독): 명령어가 어떤 작업을 해야 하는지 해석한다.
            - Execute (실행): 명령어에 따라 연산을 수행한다.
            - Memory Access (메모리 접근): 필요한 데이터를 메모리에서 읽거나, 결과를 메모리에 쓴다.
            - Write Back (결과 저장): 연산 결과를 레지스터에 저장한다.

            - -> 각 단계가 끝날 때마다 다음 명령어 처리를 시작해서, 여러 명령어가 동시에 다른 단계를 수행하도록 만드는 거야.

            - 장점
                - CPU의 처리 효율이 대폭 올라감.
                - 여러 작업을 동시에 진행하니까, CPU가 쉬는 시간이 줆.

            - 한계:

                - 파이프라인 해저드(Pipeline Hazard) 문제가 생길 수 있음.
                - 🚨 데이터 해저드: 이전 명령어 결과가 필요한데, 결과가 아직 나오지 않았을 때.
                - 🚨 제어 해저드: 분기문(조건문, 반복문) 같은 걸 만나서, 다음에 어떤 명령어가 실행될지 확실하지 않을 때. 
                
            - CPU는 이런 문제들을 해결하기 위해, 명령어 재배치나 파이프라인 중단(스톨, Stall) 같은 기법을 써서 파이프라인이 깨지지 않도록 한다고 함. *


    - *시스템 호출(System Call)
        - printf 같은 함수를 호출할 때, 단순한 라이브러리 함수 호출이 아니라 커널 모드로 전환하는 시스템 호출이 일어남.
        - 시스템 호출은 운영체제와 상호작용할 때 사용돼, 파일 읽기/쓰기, 프로세스 생성, 메모리 할당 같은 작업에서 꼭 필요함. *

    - 실행파일을 유닉스 시스템에서 실행하기 위해서 쉘이라는 응요프로그램에 그 이름을 입력한다.
    
    - 쉘: 커맨드라인 인터프리터로 프롬프트를 출력하고 명령어 라인을 입력 받아 그 명령을 실행함. -> 내장 쉘 명령어가 아니면, 실행파일의 이름으로 판단하여 그 파일을 로딩하여 실행함. -> 다음 입력 명령어 라인을 기다림.
        
    - 1.4.1 시스템의 하드웨어 조직
        - 버스(Buses)
            - 시스템 내를 관통하는 전기적 배선군. / 컴포넌트들 간에 바이트 정보들을 전송함.
            - 워드(word): 고정 크기의 바이트 단위 --> 이 단위로 데이터를 전송한다고 함.

        - 입출력 장치
            - 시스템과 외부세계와의 연결을 담당.
            - 입출력 버스와 입출력 장치들 간에 정보를 주고받고록 해주는 일을 맡는다.

        - 메인 메모리
            - 프로세서가 프로그램을 실행하는 동안 데이터와 프로그램을 모두 저장하는 임시 저장장치.
            - 물리적인 메모리는 DRAM이라는 칩들로 구성되어 있음.
            - 일반적으로 한 개의 프로그램을 구성하는 각 기계어 인스트럭션은 다양한 바이트 크기를 갖는다
                - 리눅스 x86-64 컴퓨터를 예로,int, float은 4바이트, long, double은 8바이트를 필요로 함. 
        - 프로세서(주처리장치 / CPU)
            - 메인 메모리에 저자된 인스트럭션들을 해독(실행)하는 엔진.
            - 워드 크기의 저장창지(또는 레지스터)인 프로그램 카운터(PC)가 있음. --> PC가 어느 한순간 메인 메모리의 기계어 인스트럭션을 가리킴.
            - 전원이 공급된 순간부터 전원이 끊어질 때까지, 프로그램 카운터가 가리키는 곳의 인스트럭션을 반복적으로 실행하고, PC값이 다음 인스트럭션의 위치를 가리키도록 업데이트 함.
            - 자신의 인스트럭션 집합 구조로 정의되는 매우 단순한 인스트럭션 실행 모델을 따라 작동하는 것처럼 보임. / 이 모델에서 인스트럭션들은 규칙적인 순서로 실행되고, 한개의 인스트럭션을 실행하는 것은 여러 단계를 수행함으로써 이루어진다고 함.
            - 프로세서는 PC가 메모리로부터 인스트럭션을 읽어오고, 여기서 비트들을 해석하여 인스트럭션이 지정한 간단학 동작을 실행하고, 다음 인스트럭션 위치로 업데이트 한다. --> 이 새로운 위치는 수행한 인스트럭션과 메모리 상에서 연속적일 수도 있고, 그렇지 않을 수 도 있음.

            - 메인 메모리, 레지스터 파일, 수식/논리 처리기(ALU) 주위를 순환함.
                - 레지스터 파일: 각각 고유의 이름을 갖는 워드 크기의 레지스터 집합으로 구성되어 있음.
                - ALU: 새 데이터와 주소 값을 계산함.

            - 인스트럭션의 요청에 의해 CPU가 실행되는 단순한 작업의 예
                - 적재(Load): 메인 메모리에서 레지스터에 한 바이트 또는 워드를 이전 갑에 덮어스는 방식으로 복사.
                - 저장(Store): 레지스터에서 메인 메모리로 한 바이트 또는 워드를 이전 값을 덮어쓰는 방식으로 복사.
                - 작업(Operate): 두 레지스터의 값을 ALU로 복사하고 두 개의 워드로 수식연산을 수행한 뒤, 결과를 덮어쓰기 방식으로 레지스터에 저장.
                - 점프(Jump): 인스트럭션 자신으로부터 한 개의 워드를 추출하고, 이것을 PC에 덮어쓰기 방식으로 복사.

    - 1.4.2 hello 프로그램의 실행
        - 1. 쉘 프로그램은 각각의 문자를 레지스터에 읽어들인 후, 메모리에 저장한다.
        - 2. 키보드에서 엔터 키를 누르면 쉘은 명령 입력을 끝마쳤다는 것을 알게 됨.
        - 3. 쉘은 파일 내의 코드와 데이터를 복사하는 일련의 인스트럭션을 실행하여 실행파일을 디스크에서 메인 메모리로 로딩함.
        - 4. 데이터 부분은 최종적으로 출력되는 문자 스트링을 포함한다.

        - 직접 메모리 접근(DMA)라고 하여, 이 기법을 사용하면 데이터는 프로세서를 거치지 않고 디스크에서 메인 메모리로 직접 이동한다고 함.

        - 결론
            - 1. 목적파일의 코드와 데이터가 메모리에 적재됨
            - 2. 프로세서는 프로그램의 main 루틴의 기계어 인스트럭션을 실행하기 위해 시작함.
            - 3. 인스트럭션들은 스트링을 메모리로부터 레지스터 파일로 복사하고, 거기로부터 디스플레이 장치로 전송하여 화면에 출력함.
------------------------------------------------------------
## 1주차 범위: 배열, 문자열, 반복문과 재귀 함수, 복잡도(BigO,시간,공간), 정렬, 완전 탐색, 정수론

### 공부 키워드
* 배열
    - 파이썬의 경우, 배열을 리스트(list)와 튜플(tuple)로 구현할 수 있다.
   
    - 리스트는 원소를 변경할 수 있는 뮤터블 list형 객체이다.
        - list = [] --> [] 빈 리스트 
        - list = [1, 2, 3] --> [1, 2, 3]
        - list = ['A', 'B', 'C', ] --> ['A', 'B', 'C']
   
    - 튜플
        - 원소에 순서를 매겨 결한합 것으로 원소를 변경할 수 없는 이뮤터블 자료형이다. // () 생략 가능

    - 리스트나 튜플의 원소에 접글할 떄는 인덱스를 사용한다. 

    - 슬라이스: 리스트 또는 튜플의 원소 일부를 연속해서 또는 일정한 간격으로 꺼내 새로운 리스트 또는 튜플을 만드는 것.
        - ex) s[i:j] --> s[i]부터 s[j-1]까지 나열
        - ex) s[i:j:k] --> s[i]부터 s[j-1]까지 k씩 건너뛰며 나열

    - ** 변수에 어떤  겂을 대입하면 값이 아니라, 식별 번호가 바뀐다."

    - [Practice/ListTest.py](/PracticePy/ListTest.py)

* 문자열
    - 문자열 인덱스
        - 문자열이름 = 'abc' // 문자 각자가 번호를 가지고 있는데, 번호는 0번부터 시작하여 측정한다. 
        - -3,-2, -1 // 0, 1, 2
        
    - 문자열 슬라이스
        - 문자열[2:5] --> 2번부터 4번까지의 문자를 가짐
        - 문자열[-5:-1] --> -5번부터 -2번까지의 문자를 가짐
        - 문자열[5:] --> 5번부터 끝까지 가져옴
        - 문자열[:5] --> 0번부터 4번까지 가져옴
        - 문자열[:] --> 처음부터 끝까지 가져옴
        - 문자열[2:5:?] -> 2번부터 4번까지 ?씩 건너뛰어 가져옴 // ?가 음수일떄, 거꾸로 가져옴 + 한칸 더 내려갈 수 있도록 해야함
        - 문자열[::-1] --> 처음부터 끝까지 문자열 뒤집어서 가져옴

    - 문자열 메소드
        - 1. 출력 지정: format(a,b,c,...)
            - 넣고 싶은것을 대체하여 넣을 수 있게 해줌

        - 2. 대체하기: replace(a,b)
            - replace(내가 바꾸고 싶은 대상, 바꾸고 싶은 값)

        - 3. 자르기: split(a)
            - split(자르고자 하는 구분자)

        - 4. 합치기: a.join()
            - 문자와 문자를 합칠떄 / 리스트에 있는것들을 합칠 떄 사용
            - 합칠문자.join(합칠문자)
        
        - 5. 개수 확인하기: count(a)
            - count(전체 문자열에서 몇개가 있는지 확인하고 싶은 값)

        - 6. 제거하기: strip(a) / lstrip(a) / rstrip(a)
            - strip(거슬려서 제거하고 싶은거) // l+ 이면 왼쪽, r+ 이면 오른쪽 --> 중간값은 제거 못함

        - 7. 인덱스 찾기: find(a) / rfind(a) / index(a) / rindex(a)
            - (왼쪽에서 내가 찾는 값을 찾아줌) // 기본이 왼쪽부터, r+ 오른쪽 // {index - 왼쪽부터, rindex - 오른쪽부터} --> 없는 것을 찾으라고 할때, 에러가 남. (find는 -1값이 나옴)

        - 8. 확인하기: isalpha() / isdigit() / isalnum() / isupper() / islower
            - 반환을 True / False로 함
            - isalpha() : 알파벳으로만 이루어져있는가
            - isdigit() : 숫자로만 이루어져있는가
            - isalnum() : 숫자와 알파벳의 조합으로 이루어져있는가
            - isupper() : 대문자로 이루어져있는가
            - islower() : 소문자로 이루어져있는가

        - 9. 대 / 소문자 만들기 : upper() / lower()
            - upper() : 대문자로 바꾸어라
            - lower() : 소문자로 바꾸어라

        - 10. 0 채우기 : zfill()
            - 항상 0이 출력되어야 할 때, 부족한 부분에 필요한 만큼 채워줌
            

    - [PracticePy/StringsTest.py](PracticePy/StringsTest.py)

* 반복문과 재귀 함수
    - 반복문
        - for 문
        - while 문

        - [PracticePy/LoopAndReTest.py](PracticePy/LoopAndReTest.py)

    - 재귀 함수
        - 자기 자신을 부르는 함수(함수내에서 자기자신을 사용하는 함수)
        - 큰 문제를 풀기 위해 작은 문제의 답을 사용해야할 때 사용됨

* 복잡도(BigO,시간,공간) : 알고리즘의 효율성을 나타내는 지표
    - 시간 복잡도: 실행에 걸리는 시간
    - 공간 복잡도: 사용되는 메모리 크기
    - 빅오 표기법 (Dig-O Notation)
        - O(1) -> 상수 시간 (ex: 인덱스로 접근)
        - O(log N) -> 로그 시간 (ex: 이진 탐색)
        - O(N) -> 선형 시간 (ex: 리스트 순회)
        - O(N^2) -> 제곱 시간 (ex: 이중 반복문)
        - O(2^N) -> 지수 시간 (ex: 피보나치 재귀)

* 정렬
    - 선택 정렬: 전체에서 최소값을 찾고, 맨앞과 자리를 바꾼다. 이를 반복한다.
        - 시간 복잡도: O(N²) (모든 요소를 두 번씩 비교하기 때문)
            
    - 버블 정렬: 앞에서부터 인접한 두 값씩 비교하며, 더 큰값을 뒤로 보낸다.
        - 시간 복잡도: O(N²) (모든 요소를 계속 비교하기 때문)

    - 셀 정렬: 단순 삽입 정렬의 장점을 살리면서 단점을 보완한 것.
        - 1. 먼저 정렬한 배열의 원소를 그룹으로 나워 각 그룹별로 정렬을 수행한다.
        - 2. 정렬된 그룹을 합치는 작업을 반복하여 원소의 이동 횟수를 줄이는 방법이다.
        - 시간 복잡도: O(N log N) (최적의 경우)

* 완전 탐색
    - 가능한 모든 경우의 수를 다 탐색하며 정답을 찾는 방법
    - 시간 복잡도: O(N!) 또는 O(2^N)일 때도 많아.

* 정수론 : 숫자들의 관계와 속성을 다루는 수학 분야. 프로그래밍에서는 주로 최대공약수, 최소공배수, 소수 판별 등
    - 최대공약수 (GCD)
    - 최소공배수 (LCM)
    - 소수 판별 (Prime Check)
------------------------------------------------------------