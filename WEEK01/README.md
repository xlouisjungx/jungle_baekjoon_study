------------------------------------------------------------
# jungle_study
------------------------------------------------------------
### 1주차 공부 README
* 교재에 대한 공부와 공부 키워드에 따른 공부를 작성합니다.
------------------------------------------------------------
## 1주차 범위: ~1.4 프로세서는 메모리에 저장된 인스트럭션을 읽고 해석한다.

### 책읽기
* 1.1 정보는 비트와 컨텍스트로 이루어진다

    - 정보는 비트와 컨텍스트로 이루어진다.

    - 대부분 텍스트 문자를 아스키(ASCII) 표준을 사용 -> 각 바이트는 특정 문자에 대응 되는 정수값을 갖는다. ex) 35 = #, \n도 정수 값 10으로 표시된다.

    - 텍스트 파일: 오로지 아스키 문자들로만 이루어진 파일들

    - 파이너리 파일: 다른 모든 파일들

    - 시스템 내부의 정보 - 디스크 파일, 메모리상의 프로그램, 데이터, 네트워크를 통해 전송되는 데이터 - -> 비트들로 표시

* 1.2 프로그램은 다른 프로그램에 의해 다른 형태로 번역된다

    - 각 C 문장들은 다른 프로그램들에 의해 저급 기계어 인스트럭션들로 번역되어야 하는데, 이 인스트럭션들이 [실행가능 목적 프로그램] or [실행가능 목적 파일]의 형태로 합쳐져 [바이너리 디스크 파일]로 저장된다.

    - 컴파일 시스템 : [전처리기, 컴파일러, 어셈블러, 링커]

    - 전처리 단계
        - 본래의 C 프로그램 --> .i로 끝나는 새로운 C 프로그램이 생성 // 어떤 일을 하라고 지시하는 것. 

    - 컴파일 단계
        - 텍스트 파일 파일명.i --> 텍스트파일 파일명.s로 번역 // 어셈블리어 프로그램 저장
        - *어셈블리어: 여러 상위수준 언어의 컴파일러들을 위한 공통의 출력언어를 제공하기 떄문에 유용하다. ex) C, Fortran

    - 어셈블리 단계
        - 어셈블러가
        - [1] 파일명.s를 기계어 인스트러셔으로 번역함.
        - [2] 재배치가능 목적프로그램의 형태로 묶어서,
        - [3] 파일명.o라는 목적파일에 그 결과를 저장함.
            - --> 이 파일은 main 함수의 인스트럭션들을 인코딩하기 위한 17바이트를 포함하는 바이너리 파일이다. 

    - 링크 단계
        - 우리가 C에서 흔히 쓰는 printf는 C 라이브러리에 들어있는 printf 함수를 호출하여 사용되는 것이다.  이 printf 함수는 이미 컴파일된 별도의 목적파일인 printf.o가 들어 있으며, 어떤 파일이랑 어떤 형태로든 결합이 되어야하는데, 이를 링커 프로그램이 이 통합작업을 수행한다.
        - --> [파일명] 파일은 실행가능 목적파일(실행파일)로 메모리에 적재되어 시스템에 이해 실행된다.  

* 1.3 컴파일 시스템이 어떻게 동작하는지 이해하는 것은 중요하다

    - 어떻게 컴파일 시스템이 동작하는지 이해해야 하는 중요한 이유가 있다.
        - 프로그램 성능 최적화하기
        - 링크 에러 이해하기
        - 보안 약점 피하기
            - 오버플로우 취약성이 보안 약점의 주요 원인.
            - 프로그램 스택에 데이터와 제어 정보가 저장되는 방식 때문에 생겨나는 영향을 이해 하는 것.

* 1.4 프로세서는 메모리에 저장된 인스트럭션을 읽고 해석한다
    - 1.4.1 시스템의 하드웨어 조직
    - 1.4.2 hello 프로그램의 실행
------------------------------------------------------------
## 1주차 범위: 배열, 문자열, 반복문과 재귀 함수, 복잡도(BigO,시간,공간), 정렬, 완전 탐색, 정수론

### 공부 키워드
* 배열
    - 파이썬의 경우, 배열을 리스트(list)와 튜플(tuple)로 구현할 수 있다.
   
    - 리스트는 원소를 변경할 수 있는 뮤터블 list형 객체이다.
        - list = [] --> [] 빈 리스트 
        - list = [1, 2, 3] --> [1, 2, 3]
        - list = ['A', 'B', 'C', ] --> ['A', 'B', 'C']
   
    - 튜플
        - 원소에 순서를 매겨 결한합 것으로 원소를 변경할 수 없는 이뮤터블 자료형이다. // () 생략 가능

    - 리스트나 튜플의 원소에 접글할 떄는 인덱스를 사용한다. 

    - 슬라이스: 리스트 또는 튜플의 원소 일부를 연속해서 또는 일정한 간격으로 꺼내 새로운 리스트 또는 튜플을 만드는 것.
        - ex) s[i:j] --> s[i]부터 s[j-1]까지 나열
        - ex) s[i:j:k] --> s[i]부터 s[j-1]까지 k씩 건너뛰며 나열

    - ** 변수에 어떤  겂을 대입하면 값이 아니라, 식별 번호가 바뀐다."

    - [Practice/ListTest.py](/PracticePy/ListTest.py)

* 문자열
    - 문자열 인덱스
        - 문자열이름 = 'abc' // 문자 각자가 번호를 가지고 있는데, 번호는 0번부터 시작하여 측정한다.
        
    - 문자열 슬라이스

    - 문자열 메소드

    - [PracticePy/StringsTest.py](PracticePy/StringsTest.py)

* 반복문과 재귀 함수
    - 반복문
        - [PracticePy/LoopAndReTest.py](PracticePy/LoopAndReTest.py)

    - 재귀 함수
        - 자기 자신을 부르는 함수(함수내에서 자기자신을 사용하는 함수)
        - 큰 문제를 풀기 위해 작은 문제의 답을 사용해야할 때 사용됨

* 복잡도(BigO,시간,공간)

* 정렬
    - 선택 정렬
            
    - 버블 정렬

* 완전 탐색

* 정수론
------------------------------------------------------------