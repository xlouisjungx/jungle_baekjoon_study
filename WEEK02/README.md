------------------------------------------------------------
# jungle_study
------------------------------------------------------------
### 2주차 공부 README
* 교재에 대한 공부와 공부 키워드에 따른 공부를 작성합니다.
------------------------------------------------------------
## 2주차 범위: 1.5. 캐시가 중요하다 ~ 1.7. 운영체제는 하드웨어를 관리한다

### 책읽기

* 
* 

------------------------------------------------------------
## 2주차 범위: 이분 탐색, 분할 정복, 스택, 큐, 우선순위 큐, Linked List, 해시 테이블

### 공부 키워드

* 이분탐색
    - 정렬된 상태의 집합에서 중간 값을 찾고 비교하여 더 큰지 작은지 판단후 다시 범위를 설정하여 비교한다.
        - 만약 데이터 집합에 찾는 값이 없다면? -> 찾는 값이 존재할 수 있는 범위가 점점 줄다가 사라지고, 그 값이 없는 것으로 탐색을 종료하게 된다.

    - 장점: 선형 탐색에 비해 더 빠른 탐색 속도를 자랑한다.
    - 단점: 정렬되어있는 집합에서만 사용할 수 있다는 것이 단점이다.

    - 예시: up & down 게임
        - 외친 숫자가 정답인 수 보다 크면 다운, 작으면 업을 외쳐 수를 찾는 게임

    - *파라메트릭 서치: 결정 문제를 최적화 알고리즘으로 변환하는 알고리즘 설계 기법 중 하나*
        - isBasVersion() // 최적화 문제를 결정 문제로 바꿔 해결하는 방법이다. (함수를 만들어야함)

* 분할정복
    -  큰 문제를 작은 부분 문제로 분할하고, 각각의 작은 부분 문제를 해결하여 전체 문제의 해답을 구하는 알고리즘
        - 문제의 크기가 커서 직접적인 해결이 어려운 경우 유용하다. ex) 병합 정렬, 퀵 정렬
    - 해결과정
    - 1. Divide -> 기존 문제를 작은 부분문제들로 나눔
    - 2. Conquer -> 각 부분문제를 해결(정복) / 이 부분들도 상황에 따라, Divide, Conquer, Combine으로 나누어 해결할 수 있음
    - 3. Combine -> 부분문제들의 솔루션을 통해 기존 문제를 해결

    - Basecase: 이미 문제가 충분히 작아서, 더 작은 부분 문제로 나누지 않아도 바로 답을 알 수 있는 경우
    - Recursive case: 문제가 커서 바로 답을 알 수 없어서, 같은 형태의 부분 문제들로 쪼개서 풀어야 하는 경우

    - 시간 복잡도 ( 부분 문제의 개수, 분할된 문제의 크기, 분할과정의 복잡도에 따라 결정 )
        - 분할 정복 알고리즘은 재귀를 사용하여 문제를 해결하므로, 재귀 호출의 깊이에 따라 시간 복잡도가 결정된다.
        - 분할된 문제들의 크기가 일정하다면, 재귀 호출의 깊이는 로그 시간 복잡도에 비례.

    *분할된 문제의 개수가 N이라면, 시간 복잡도는 O(N*logN)*

    - 분할된 문제의 개수가 지수적으로 증가하거나 분할된 문제들이 크기가 일정하지 않은 경우, 시간 복잡도가 지수적으로 증가할 수 있음.

    - 병합 정렬
        - 분할과 정복을 모두 사용하여 리스트를 반으로 나누어 각각을 재귀적으로 정렬하고, 두 개 의 부분 리스트를 합쳐 전체 리스트를 정렬하는 방식

        - 동작 과정
            - 1. 분할: 입력 리스트를 반으로 나눈다.
            - 2. 정복: 각각의 부분 리스트를 재귀적으로 병합 정렬한다.
            - 3. 결합: 정렬된 부분 리스트를 합쳐 전체 리스트를 정렬한다.

    - 퀵 정렬
        - 분할과 정복을 사용하여 리스트를 분할하고, 각각을 재귀적으로 정렬한 다음, 전체 리스트를 합치지 않고 원래 위치에 놓여있는 것을 기준으로 정렬 (정렬을 위해 별도의 저장 공간을 필요호 하지 않아 메모리 사용량이 적다.)

        - 동작과정
            - 1. 피벗 선택: 리스트에서 하나의 원소를 기준점으로 선택한다.
            - 2. 분할: 기준점을 기준으로 리스트를 두 개로 분할. 분할된 두 개의 리스트는 각각 기준점보다 작은 값과 큰값으로 이루어짐.
            - 3. 정복: 각각의 부분 리스트를 재귀적으로 퀵 정렬 한다.
            - 4. 결합: 정렬된 부분 리스트를 합쳐 전체 리스트를 정렬한다.



    - 퀵 정렬

    

* 스택

* 큐웹

* 우선순위 큐

* Linked List

* 해시테이블

------------------------------------------------------------
* 문제 풀어보기

* 1920 수 찾기
    - main branch

* 10816	숫자 카드 2
    - [10816..py](10816.py)
    - 시간 초과 문제 발생

* 1654 랜선 자르기
    - [1654.py](1654.py)

* 2805 나무 자르기
    - main branch
------------------------------------------------------------