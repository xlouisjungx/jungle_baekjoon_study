------------------------------------------------------------
# jungle_study
------------------------------------------------------------
### 2주차 공부 README
* 교재에 대한 공부와 공부 키워드에 따른 공부를 작성합니다.
------------------------------------------------------------
## 2주차 범위: 1.5. 캐시가 중요하다 ~ 1.7. 운영체제는 하드웨어를 관리한다

### 책읽기

* 1.5 캐쉬가 중요하다.

    - 여러 복사과정들이 프로그램의 "실제 작업"을 느리게 하는 오버헤드이다.
    - 설계자들의 주요 목적은 이러한 복사과정들을 가능한 한 빠르게 동작하도록 하는 것.

    - 더 큰 저장장치들은 보다 작은 저장장치들보다 느린 속도를 갖는다.(비용도 빠른거 만드는게 더 오래걸림)

    - 일반적인 레지스터 파일은 수백 바이트의 정보를 저장하는 반면, 메인 메모리의 경우는 십억 개의 바이트를 저장.
        - 그러나 프로세서는 레지스터 파일의 데이터를 읽는 데 메모리의 경우보다 거의 100배 빨리 읽을 수 있다.
        - 기술이 발전함에 따라, 프로세서-메모리 간 격차가 지속적으로 증가하고 있다.

    - 프로세서-메모리 간 격차에 대응하기 위해 시스템 설계자는 보다 작고 빠른 캐시 메모리(캐시)라고 부르는 저장장치를 고안하여, 프로세서가 단기간에 필요로 할 가능성이 높은 정보를 임시로 저장할 목적으로 사용.
        - L1 캐시: 대략 수천 바이트의 데이터를 저장할 수 있으며, 거의 레지스터 파일만큼 빠른 속도로 엑세스할 수 있음.
        - L2 캐시: 수백 킬로바이트에서 수 메가 바이트의 용량을 가지며 프로세서와 전용 버스를 통해 연결.
        - L2 캐시를 엑세스할 때 L1 캐시보다 5배 정도 느리지만, 그래도 여전히 메인 메모리를 엑세스할 때보다는 5배에서 크게는 10배까지 더 빠르다.

    - 보다 새롭고 보다 강력한 시스템은 3단계의 캐시를 갖는 경우도 있다.
        - L1, L2 캐시는 SRAM이라는 하드웨어 기술을 이용해 구현.
        - 캐시 시스템의 이면에 깔려 있는 아이디어는 프로그램이 지엽적인 영역의 코드와 데이터를 엑세스하는 경향인 "지역성"을 활용하여 시스템이 매우 크고 빠른 메모리 효과를 얻을 수 있음.
        - 자주 엑세스할 가능성이 높은 데이터를 캐시가 보관하도록 설정하면 빠른 캐시를 이용해서 대부분의 메모리 작업을 수행할 수 있게 됨.

    - 캐시 메모리를 이애하는 응용 프로그래머는 캐시를 활용하여 자신의 프로그램 성능을 10배 이상 개선할 수 있다.

* 1.6 저장장치들은 계층구조를 이룬다
    - 보다 작고 빠른 저장장치(예. 캐시메모리)를 프로세서와 좀 더 크고 느린 장치(예. 메인메모리) 사이에 끼워 넣는 개념은 일반적인 아이디어로 판명됨.
    
    - 모든 컴퓨터 시스템의 저장장치들은 "메모리 계층구조"로 구성되어 있다. 계층의 꼭대기에서부터 맨 밑바닥까지 이동할수록 저장장치들은 더 
    느리고, 더 크고, 바이트당 가격이 싸진다.
    
    - 레지스터 파일은 계층구조의 최상위인 레벨 0, 즉 L0를 차지한다. 메인 메모리는 레벨 4에 위치한다.
    
    - 메모리 계층구조의 주요 아이디어는 한 레벨의 저장장치가 다음 하위레벨 저장장치의 캐시 역할을 한다는 것이다.
        - L1과 L2의 캐시는 각각 L2와 L3의 캐시이다. L3 캐시는 메인 메모리의 캐시이고, 이 캐시는 디스크의 캐시 역할을 한다.
        - 일부 분산 파일시스템을 가지는 네트워크 시스템에서 로컬 디스크는 다른 시스템의 디스크에 저장된 데이터의 캐시 역할을 수행한다.
    
    - 로컬디스크들은 원격 네트워크 서버에서 파일들을 가져와 보관한다. 프로그래머들이 성능을 개선하기 위해서 다른 종류의 캐시들을 활용할 수 있듯이 프로그래머는 전체 메모리 계층구조에 대한 지식을 활용할 수 있다.

* 1.7 운영체제는 하드웨어를 관리한다.
    - 프로그램이 메시지를 출력할 때, 프로그램이 키보드나 디스플레이, 디스크나 메인 메모리를 직접 엑세스하지 않았다. 오히려 운영체제가 제공하는 서비스를 활용. 하드웨어와 소프트웨어 사이에 위치한 소프트웨어 계층으로 생각할 수 있다. 응용프로그램이 하드웨어를 제어하려면 언제나 운영체제를 통해서 해야 한다.

    - 운영체제의 목적
        - 1) 제멋대로 동작하는 응용프로그램들이 하드웨어를 잘못 사용하는 것을 막기 위해
        - 2) 응용프로그램들이 단순하고 균일한 메커니즘을 사용하여 복잡하고 매우 다른 저수준 하드웨어 장치들을 조작할 수 있도록 하기 위해

    - 프로세스, 가상메모리, 파일. / 파일은 입출력장치의 추상화이고, 가상메모리는 메인 메모리와 디스크 입출력 장치의 추상화, 그리고 프로세스는 프로세서, 메인 메모리, 입출력장치 모두의 추상화 결과이다.

    * 1.7.1 프로세스
        - 실행 중인 프로그램에 대한 운영체제의 추상화.
        
        - 다수의 프로세스들은 동일한 시스템에서 동시에 실행될 수 있으며, 각 프로세스는 하드웨어를 배타적으로 사용하는 것처럼 느낌.
            
            - 동시에 라는 말은 한 프로세스의 인스트럭션들이 다른 프로세스의 인스트럭션들과 섞인다는 의미.
            
            - 대부분의 시스템에서 프로세스를 실행할 CPU의 숫자보다 더 많은 프로세스들이 존재한다. 이전의 시스템들은 한 번에 한개이 프로그램만 실행할 수 있었지만, 요즘의 멀티코어 프로세서들은 여러 개의 프로그램을 동시에 실행할 수 있다.

            - 결론: 프로세서가 프로세스들을 바꿔주는 방식으로 한 개의 CPU가 다수의 프로세스를 동시에 실행하는 것처럼 보이게 해준다.

        - 운영체제는 "문맥 전환"이라는 방법을 사용해서 이러한 교차실행을 수행. 나머지 논의를 간단히 하기 위해서 한 개의 CPU를 가지는 단일 프로세서 시스템만을 고려.

        - 프로세스가 실행하는 데 필요한 모든 상태정보의 변화를 추적.
        
        - 컨텍스트라고 부르는 상태정보는 PC, 레지스터 파일, 메인 메모리의 현재 값을 포함하고 있다.

        - 단일 프로세서 시스템은 한 개의 프로세스의 코드만을 실행할 수 있다.

        - 운영체제는 현재 프로세스에서 다른 새로운 프로세스로 제어를 옮기려고 할 때 현재 프로세스의 컨텍스트를 저장하고 새 프로세스의 컨텍스트를 복원시키는 문맥전환을 실행하여 제어권을 새 프로세스로 넘겨줌. 새 프로세스는 이전에 중단헀던 바로 그 위치부터 다시 실행.

        - 동시성 프로세스: 쉘 프로세스와 [파일명] 프로세스. 처음에는 쉘 프로세스가 혼자서 동작하고 있다가 명령줄에서 입력을 기다림.

        - 커널: 하나의 프로세스에서 다른 프로세스로의 전환을 관리. / 운영체제 코드의 일부분으로 메모리에 상주함. 
            - 별도의 프로세스가 아니라는 점에 유의해야 함.
            - 모든 프로세스를 관리하기 위해 시스템이 이용하는 코드와 자료 구조의 집합.

    * 1.7.2 쓰레드(Thread)
        - 다수의 실행 유닛.
        - 각각의 쓰레드는 해당 프로세스의 컨텍스트에서 실행되며 동일한 코드와 전역 데이터를 공유한다.
        - 프로그래밍 모델로서의 중요성이 더욱 커지고 있는데, 그 이유로는 다수의 프로세스들에서보다 데이터의 공유가 더 쉽다는 점과 쓰레드가 프로세스보다 더 효율적이라는 점 때문. 

        - 다중 쓰레딩도 다중 프로세서를 활용할 수 있다면 프로그램의 실행 속도를 빠르게 하는 한 가지 방법이다.

    * 1.7.3 가상메모리
        - 각 프로세스들이 메인 메모리 전체를 독점적으로 사용하고 있는 것 같은 환상을 제공하는 추상화이다.
        - 각 프로세스는 가상주소 공간이라고 하는 균일한 메모리의 모습을 갖게 된다. 리눅스에서, 주소공간의 최상위 영역은 모든 프로세스들이 공통으로 사용하는 운영체제의 코드와 데이터를 위한 공간이다. 주소공간의 하위 영역은 사용자 프로세스의 코드와 데이터를 저장한다.

        - 각 프로세스들에게 보여지는 가상주소공간은 몇 개의 정의된 영역으로 구성되어 있음.

        - 프로그램 코드와 데이터, 코드는 모든 프로세스들이 같은 고정 주소에서 시작하며, 다음에 C 전역변수에 대응되는 데이터 위치들이 따라옴. 코드와 데이터 영역은 실행가능 목적파일로부터 직접 초기화.

        - 힙, 코드와 데이터 영역 다음으로 런타임 힙이 따라옴. 크기가 고정되어 있는 코드, 데이터 영역과 달리, 힙은 프로세스가 실행되면서 C 표준함수인 malloc이나 free를 호출하면서 런타임에 동적으로 그 크기가 늘었다 줄었다 함. 

        - 공유 라이브러리. 주소공간의 중간 부근에 C 표준 라이브러리나 수학 라이브러리와 같은 공유 라이브러리의 코드와 데이터를 저장하는 영역이 있음. 공유 라이브러리 개념은 강력하지만 다소 어려운 개념.

        - 스택. 사용자 가상메모리 공간의 맨 위에 컴파일러가 함수 호출을 구현하기 위해 사용하는 사용자 스택이 위치함. 힙과 마찬가지로 사용자 스택은 프로그램이 실행되는 동안에 동적으로 늘어났다 줄어들었다 함. 특히, 함수를 호출할 때마다 스택이 커지며, 함수에서 리턴될 때는 줄어듦.

        - 커널 가상메모리. 주소공간의 맨 윗부분은 커널을 위해 예약되어 있음. 응용프로그램들은 이 영역의 내용을 읽거나 쓰는 것이 금지되어 있으며, 마찬가지로 커널 코드 내에 정의된 함수를 직접 호출하는 것도 금지되어 있음. 대신 이런 작업을 수행하기 위해서는 커널을 호출해야 함.

        - 가상메모리가 작동하기 위해서는 프로세서가 만들어내는 모든 주소를 하드웨어로 변역하는 등의 하드웨어와 운영체제 소프트웨어 간의 복잡한 상호작용이 필요. 기본적인 아이디어는 프로세스의 가상메모리의 내용을 디스크에 저장하고 메인 메모리를 디스크의 캐시로 사용하는 것.

    * 1.7.4 파일
        -  그저 연속된 바이트들. 디스크, 키보드, 디스플레이, 네트워크까지 포함하느 모든 입출력장치는 파일로 모델링함. 시스템의 모든 입출력은 유닉스 I/O라는 시스템 콜들을 이용하여 파일을 읽고 쓰는 형태로 이루어짐.

        - 간단하면서도 고상한 파일 개념은 매우 강력한 것이어서 응용프로그램에 시스템에 들어 있는 다양한 입출력장치들의 통일된 관점을 제공한다.
            - 디스크 파일의 내용을 조작하려는 응용 프로그래머는 다행스럽게도 사용하고 있는 특정 디스크의 기술에 대해서는 몰라도 된다고 함. 동일한 프로그램이 다른 디스크 기술을 사용하는 다른 시스템에서도 실행될 수 있음.
            
------------------------------------------------------------
## 2주차 범위: 이분 탐색, 분할 정복, 스택, 큐, 우선순위 큐, Linked List, 해시 테이블

### 공부 키워드

* 이분탐색
    - 정렬된 상태의 집합에서 중간 값을 찾고 비교하여 더 큰지 작은지 판단후 다시 범위를 설정하여 비교한다.
        - 만약 데이터 집합에 찾는 값이 없다면? -> 찾는 값이 존재할 수 있는 범위가 점점 줄다가 사라지고, 그 값이 없는 것으로 탐색을 종료하게 된다.

    - 장점: 선형 탐색에 비해 더 빠른 탐색 속도를 자랑한다.
    - 단점: 정렬되어있는 집합에서만 사용할 수 있다는 것이 단점이다.

    - 예시: up & down 게임
        - 외친 숫자가 정답인 수 보다 크면 다운, 작으면 업을 외쳐 수를 찾는 게임

    - *파라메트릭 서치: 결정 문제를 최적화 알고리즘으로 변환하는 알고리즘 설계 기법 중 하나*
        - isBasVersion() // 최적화 문제를 결정 문제로 바꿔 해결하는 방법이다. (함수를 만들어야함)
        - 나무 자르기 등의 문제에 적용된다고 하니, 미리 학습하는것이 나은거같다.

* 분할정복
    -  큰 문제를 작은 부분 문제로 분할하고, 각각의 작은 부분 문제를 해결하여 전체 문제의 해답을 구하는 알고리즘
        - 문제의 크기가 커서 직접적인 해결이 어려운 경우 유용하다. ex) 병합 정렬, 퀵 정렬
    - 해결과정
    - 1. Divide -> 기존 문제를 작은 부분문제들로 나눔
    - 2. Conquer -> 각 부분문제를 해결(정복) / 이 부분들도 상황에 따라, Divide, Conquer, Combine으로 나누어 해결할 수 있음
    - 3. Combine -> 부분문제들의 솔루션을 통해 기존 문제를 해결

    - Basecase: 이미 문제가 충분히 작아서, 더 작은 부분 문제로 나누지 않아도 바로 답을 알 수 있는 경우
    - Recursive case: 문제가 커서 바로 답을 알 수 없어서, 같은 형태의 부분 문제들로 쪼개서 풀어야 하는 경우

    - 시간 복잡도 ( 부분 문제의 개수, 분할된 문제의 크기, 분할과정의 복잡도에 따라 결정 )
        - 분할 정복 알고리즘은 재귀를 사용하여 문제를 해결하므로, 재귀 호출의 깊이에 따라 시간 복잡도가 결정된다.
        - 분할된 문제들의 크기가 일정하다면, 재귀 호출의 깊이는 로그 시간 복잡도에 비례.

    *분할된 문제의 개수가 N이라면, 시간 복잡도는 O(N*logN)*

    - 분할된 문제의 개수가 지수적으로 증가하거나 분할된 문제들이 크기가 일정하지 않은 경우, 시간 복잡도가 지수적으로 증가할 수 있음.

    - 병합 정렬
        - 분할과 정복을 모두 사용하여 리스트를 반으로 나누어 각각을 재귀적으로 정렬하고, 두 개 의 부분 리스트를 합쳐 전체 리스트를 정렬하는 방식

        - 동작 과정
            - 1. 분할: 입력 리스트를 반으로 나눈다.
            - 2. 정복: 각각의 부분 리스트를 재귀적으로 병합 정렬한다.
            - 3. 결합: 정렬된 부분 리스트를 합쳐 전체 리스트를 정렬한다.

    - 퀵 정렬
        - 분할과 정복을 사용하여 리스트를 분할하고, 각각을 재귀적으로 정렬한 다음, 전체 리스트를 합치지 않고 원래 위치에 놓여있는 것을 기준으로 정렬 (정렬을 위해 별도의 저장 공간을 필요호 하지 않아 메모리 사용량이 적다.)

        - 동작과정
            - 1. 피벗 선택: 리스트에서 하나의 원소를 기준점으로 선택한다.
            - 2. 분할: 기준점을 기준으로 리스트를 두 개로 분할. 분할된 두 개의 리스트는 각각 기준점보다 작은 값과 큰값으로 이루어짐.
            - 3. 정복: 각각의 부분 리스트를 재귀적으로 퀵 정렬 한다.
            - 4. 결합: 정렬된 부분 리스트를 합쳐 전체 리스트를 정렬한다.

* 스택
    - 데이터를 임시 저장할 때 사용하는 자료구조로, 데이터의 입력과 출력 순서는 후입선출 방식이다.
        - 여기서 후입선출 방식이란? -> 가장 나중에 넣은 데이터를 가장 먼저 꺼낸다는 뜻!

    - 푸시(push): 스택에 데이터를 넣는 작업
    - 팝(pop): 스택에서 데이터를 꺼내는 작업

    - 겹쳐 쌓은 접시처럼 데이터를 넣고 꺼내는 작업을 맨 위부터 수행함.
    - 꼭대기(top): 푸시하고 팝하는 윗부분
    - 바닥(bottom): 아랫부분

    - 스택배열(stk): 푸시한 데이터를 저장하는 스택 본체인 list형 배열. / 인덱스가 0인 원소를 스택의 바닥이라고 함.
        - 가장 먼저 푸시하여 데이터를 저장하는 곳은 stk[0]이다.

    - 스택 크기(capacity): 스택의 최대 크기를 나타내는 int형 정수. 이 값은 배열 stk의 원소 수인 len(stk)와 일치함.

    - 스택 포인터(str): 스택에 쌓여 있는 데이터의 개수를 나타내는 정수값. / 스택이 비어 있으면 ptr의 값은 0이 되고 가득 차 있으면 capacity와 같은 값이 된다.

    - 에외 처리 클래스 Empty
        - pop() 함수 또는 peek() 함수를 호출할 때 스택이 비어 있으면 내보내는 예외 처리.

    - 예외 처리 클래스 Full
        - push() 함수를 호출할 떄 스택이 가득 차 있으면 내보내는 예외 처리이다.

    - 초기화하는 __init__() 함수
        - 스택 배열을 생성하는 등의 준비 작업을 수행. 
            - 작업과정
                - 매개변수 capacity로 전달받은 값을 스택의 크기를 나타내는 필드인 capacity로 복사
                - 원소 수가 capacity이고 모든 원소가 None인 리스트형 stk를 생성
                - 이때 스택이 비어있으므로 스택 포인터 ptr의 값을 0으로 한다.

    - 쌓여있는 데이터 개수를 알아내는 __len__() 함수
        - 스택에 쌓여 있는 데이터 개수를 반환. (스택 포인터 ptr값을 그대로 반환)

    - 스택이 비어 있는지를 판단하는 is_empty() 함수
        - 데이터가 하나도 쌓여 있지 않은 상태, 즉 스택이 비어 있는지를 판단. (비어 있으면 True, 비어있지 않으면 False)

    - 스택이 가득 차 있는지를 판단하는 is_full() 함수
        - 더 이상 데이터를 푸시할 수 없는 상태, 즉 스택이 가득 차 있는지 판단. (가득 차 있으면 True, 가득 차 있지  않으면 False)
        
    - 데이터를 푸시하는 push() 함수
        - 스택에 데이터를 추가한다. (가득 차있을시, FixedStack.Full을 통해 예외 처리 보냄.)
        - 전달받은 value를 배열 원소 stk[ptr]에 저장하고, 스택 포인터 ptr을 1 증가.

    - 데이터를 팝하는 pop() 함수
        - 스택의 꼭대기에서 데이터를 꺼내서 그 값을 반환. (스택이 비어있는 경우, FixedStack.Full을 통해 예외 처리 보냄.)
        - 스택이 비어있지 않을 시, 스택 포인터 ptr의 값을 1 감소시키고, stk[ptr]에 저장된 값을 반환.

    - 데이터를 들여다보는 peek() 함수
        - 스택의 꼭대기 데이터를 들여다 봄. (스택이 비어있는 경우, FixedStack.Full을 통해 예외 처리 보냄.)
        - 스택이 비어있지 않으면 꼭대기 원소 stk[ptr-1]의 값을 반환. 데이터의 입출력이 없으므로 스택 포인터는 변화X

    - 스택의 모든 데이터를 삭제하는 clear() 함수
        - 스택에 쌓여 있는 데이터를 모두 삭제하여 빈 스택을 만듦. 스택 포인터 ptr의 값을 0으로 하면 끝.

    - 데이터를 검색하는 find() 함수
        - 스택 본체의 배열 stk안에 value와 같은 데이터가 포함되어 있는지 확인하고, 포함되어 있다면 배열의 어디에 들어 있는지를 검색.

    - 데이터 개수를 세는 count() 함수
        - 스택에 쌓여 있는 데이터(value)의 개수를 구하여 반환.

    - 데이터가 포함되어 있는지 판단하는 __contains__() 함수
        - 스택에 데이터(value)가 있는지 판단. (있으면 True, 없으면 False를 반환)

    - 스택의 모든 데이터를 출력하는 dump() 함수
        - 스택에 쌓여 있는 ptr개의 모든 데이터를 바닥부터 꼭대기까지 순서대로 출력. (스택이 비어있으면, 비어있다고 출력.ssss)
    

* 큐웹
    - 스택과 같이 데이터를 임시 저장하는 자료구조. (스택처럼 가장 나중에 넣은 데이터를 가장 먼저 꺼내지 않는다.)

    - 인큐(enqueue): 큐에 데이터를 추가하는 작업

    - 디큐(dequeue): 데이터를 꺼내는 작업

    - 프런트(front): 데이터를 꺼내는 쪽(맨 앞의 원소를 가리킴.)

    - 리어(rear): 데이터를 넣는 쪽(맨 끝의 원소를 가리킴.)

    - 링 버퍼(ring buffer): 배열 맨 끝의 원소 뒤에 맨 앞의 원소가 연결되는 자료구조. 어떤 원소가 맨 앞 원소이고, 어떤 원소가 맨 끝 원소인지 식별하는 변수가 각각 front와 rear이다.

    - Empty: 비어 있는 큐에 deque(), peek() 함수를 호출할 때 내보내는 예외 처리 클래스

    - Full: 가득 차 있는 큐에 enque()함수를 호출할 때 내보내는 예외 처리하는 클래스

    - 초기화하는 __init__() 함수
        - que: 큐의 배열로서 밀어 넣는 데이터를 저장하는 list형 배열.
        - capacity: 큐의 최대 크기를 나타내는 int형 정수. 이 값은 배열 que의 원소 수와 일치.
        - front, rear: 맨 앞의 우너소, 맨 끝의 원소를 나타내는 인덱스. 큐에 넣은 데이터 중에 가장 처음에 넣은 맨 앞 원소의 인덱스가 front이고, 가장 마지막에 넣은 맨 끝 원소의 바로 다음 인덱스가 rear이다. rear는 다음에 인큐할 떄 데이터를 저장하는 원소의 인덱스.
        - no: 큐에 쌓여 있는 데이터 개수를 나타내는 int형 정수이다. 변수 front와 rear의 값이 같을 경우 큐가 비어 있는지 또는 가득 차 있는지 구별하기 위해 필요. 큐가 비어 있는 경우에는 no가 0이 되고, 가득 차 있는 경우에는 capacity와 같은 값이 된다.

    - 추가한 데이터 개수를 알아내는 __len__() 함수
        - 큐애 추가한 데이터 개수를 반환. no의 값은 그대로 반환.

    - 큐가 비어 있는지를 판단하는 is_empty() 함수
        - 큐가 비어 있는지를 판단. 비어 있으면 True를, 그렇지 않으면 False를 반환

    - 큐가 가득 차 있는지를 판단하는 is_full() 함수
        - 큐가 가득 차 있어서 더 이상 데이터를 추가할 수 없는 상태인지 검사. 가득 차 있으면 True, 그렇지 않으면 False.

    - 데이터를 넣는 enque() 함수
        - 큐에 데이터를 인큐함. 만약 큐가 가득 차서 인큐할 수 없는 경우 예외 처리인 FixedQueue.Full을 내보냄.

    - 데이터를 꺼내는 deque() 함수
        - 큐의 맨 앞부터 데이터를 디큐하여 그 값을 반환. 그러나 큐가 비어있어 디큐할 수 없는 경우 예외 처리인 FixedQueue.Epmty을 내보냄. 

    - 데이터를 들여다보는 peek() 함수
        - 맨 앞 데이터, 즉 다음 디큐에서 꺼낼 데이터를 들여다봄. que[front]의 값을 반환할 뿐 데이터를 꺼내지는 않으므로 front, rear, no의 값은 변하지 않는다. 큐가 비어 있을 때는 에외 처리 FixedQueue.Epmty를 내보냄.

    - 검색하는 find() 함수
        - 큐의 배열에서 value와 같은 데이터와 포ㅏㅁ되어 있는 위치를 알아낸다. 맨 앞에서 맨 끝 쪽으로 선형 검색을 수행. (스캔은 맨 앞 원소가 아니라 큐의 맨 앞 원소(front)부터 시작.) 따라서 스캔할 때 주목하는 인덱스 idx를 구하는 식은 (i+front) % capacity이다.

    - 데이터 개수를 세는 count() 함수
        - 큐에 있는 데이터(value)의 개수를 구하여 반환.

    - 데이터가 포함되어 있는지를 판단하는 __contains__() 함수
        - 큐에 데이터(value)가 들어 있는지를 판단. 들어 있으면 True, 그렇지 않으면 False를 반환. (내장 함수를 호출하여 구현)

    - 큐의 전체 원소를 삭제하는 clear() 함수
        - 현재 큐에 들어 있는 모든 데이터를 삭제.

    - 큐의 전체 데이터를 출력하는 dump() 함수
        - 큐에 들어 있는 모든 데이터를 맨 앞부터 맨 끝 쪽으로 순서대로 출력. 하지만 큐가 비어 있으면 '큐가 비어 있습니다.'를 출력

    - 덱?(deque: double-ended queue): 맨 앞과 맨 끝 양쪽에서 데이터를 모두 삽입, 삭제할 수 있는 자료구조. 2개의 포인터를 사용하여 양쪽에서 삭제, 삽입을 할 수 있으며, 큐와 스택을 합친 형태라고 보면 된다. 




* 우선순위 큐: 우선순위가 가장 높은 데이터를 가장 먼저 삭제하는 자료구조. (데이터를 우선순위에 따라 처리하고 싶을 때 사용)
    - 파이썬에서 우선순위를 부여하는 큐는 heapq 모듈에서 제공. 
    - heap에서 data의 인큐는 heapq.heappush(heap, data)로 수행, 디큐는 heapq.heappop(heap)로 수행.

    - 우선순위 큐를 구현하는 방법
        - 단순히 리스트를 이용하여 구현.
        - 힙(heap)을 이용하여 구현.

    - 힙(Heap)의 특징
        - 완전 이진 트리 자료구조의 일종.
        - 항상 루트 노드(root node)를 제거.
        - 최소 힙(min heap)
            - 루트 노드가 가장 작은 값을 가짐
            - 값이 작은 데이터가 우선적으로 제거.
        - 최대 힙(max heap)
            - 루트 노드가 가장 큰 값을 가짐.
            - 값이 큰 데이터가 우선적으로 제거.

    - 완전 이진 트리 (Complete Binary Tree)
        - 노드부터 작하여 왼쪽 자식 노드, 오른쪽 자식 노드 순서대로 데이터가 차례대로 삽입되는 트리(tree)를 의미.

    - 최소 힙 구성 함수: Min-Heapify()
        - (상향식) 부모 노드로 거슬러 올라가며, 부모보다 자신의 값이 더 작은 경우제 위치를 교체.


* Linked List: 연속된 노드(Node)의 연결체
    - 노드(Node): 연결리스트 에서 사용되는 하나의 데이터 덩어리, / 데이터 & 링크 이 2가지의 필드를 담고 있는 구조이다.
    - random access 불가능 : 리스트의 N번쨰 노드 방문시 O(n) 시간 소요 예) head 노드부터 n번째 노드까지 순회
    - 상황에따라 배열보다 빨라질 수 있는 노드 삽입 & 삭제

    - 종류
        - Singly Linked List (단일 연결 리스트): 다음 노드에 대한 포인터들만 가지고 있고, 한쪽 방향으로만 흐르는 구조
        - Doubly Linked List (이중 연결 리스트): 다음 노드에 대한 포인터 뿐만 아니라, 이전 노드를 가리키는 포인터 역시 가지고 있다. (데이터 구조와 흐름이 복잡해질 수 있다)
        - Circular Linked List (원형 연결 리스트): 일반적인 연결 리스트에 마지막 노드가 가리키는 포인터가 다시 처음 노드 즉, 헤드노드를 가리키게 된다.

* 해시테이블
    - 데이터를 관리 및 유지하는 자료구조 (리소스 < 속도)
    - 똑같은 데이터가 들어올때마다 똑같이 분류하는 규칙성
    - 장점: 빠른 데이터 접근 속도
    - 해싱의 충돌 대처
        - Chaining: 이미 값이 있으면, 뒤에 연결시키는 방법
        - Linear Probing: 다음 버킷 자리에 슥 넣는 방법 / 공간이 없으면 테이블 리사이징
------------------------------------------------------------
* 문제 풀어보기

* 1920 수 찾기
    - main branch

* 10816	숫자 카드 2
    - [10816..py](10816.py)
    - 시간 초과 문제 발생

* 1654 랜선 자르기
    - [1654.py](1654.py)

* 2805 나무 자르기
    - main branch
------------------------------------------------------------