------------------------------------------------------------
# jungle_study
------------------------------------------------------------
### 2주차 공부 README
* 교재에 대한 공부와 공부 키워드에 따른 공부를 작성합니다.
------------------------------------------------------------
## 2주차 범위: 1.5. 캐시가 중요하다 ~ 1.7. 운영체제는 하드웨어를 관리한다

### 책읽기

* 
* 

------------------------------------------------------------
## 2주차 범위: 이분 탐색, 분할 정복, 스택, 큐, 우선순위 큐, Linked List, 해시 테이블

### 공부 키워드

* 이분탐색
    - 정렬된 상태의 집합에서 중간 값을 찾고 비교하여 더 큰지 작은지 판단후 다시 범위를 설정하여 비교한다.
        - 만약 데이터 집합에 찾는 값이 없다면? -> 찾는 값이 존재할 수 있는 범위가 점점 줄다가 사라지고, 그 값이 없는 것으로 탐색을 종료하게 된다.

    - 장점: 선형 탐색에 비해 더 빠른 탐색 속도를 자랑한다.
    - 단점: 정렬되어있는 집합에서만 사용할 수 있다는 것이 단점이다.

    - 예시: up & down 게임
        - 외친 숫자가 정답인 수 보다 크면 다운, 작으면 업을 외쳐 수를 찾는 게임

    - *파라메트릭 서치: 결정 문제를 최적화 알고리즘으로 변환하는 알고리즘 설계 기법 중 하나*
        - isBasVersion() // 최적화 문제를 결정 문제로 바꿔 해결하는 방법이다. (함수를 만들어야함)
        - 나무 자르기 등의 문제에 적용된다고 하니, 미리 학습하는것이 나은거같다.

* 분할정복
    -  큰 문제를 작은 부분 문제로 분할하고, 각각의 작은 부분 문제를 해결하여 전체 문제의 해답을 구하는 알고리즘
        - 문제의 크기가 커서 직접적인 해결이 어려운 경우 유용하다. ex) 병합 정렬, 퀵 정렬
    - 해결과정
    - 1. Divide -> 기존 문제를 작은 부분문제들로 나눔
    - 2. Conquer -> 각 부분문제를 해결(정복) / 이 부분들도 상황에 따라, Divide, Conquer, Combine으로 나누어 해결할 수 있음
    - 3. Combine -> 부분문제들의 솔루션을 통해 기존 문제를 해결

    - Basecase: 이미 문제가 충분히 작아서, 더 작은 부분 문제로 나누지 않아도 바로 답을 알 수 있는 경우
    - Recursive case: 문제가 커서 바로 답을 알 수 없어서, 같은 형태의 부분 문제들로 쪼개서 풀어야 하는 경우

    - 시간 복잡도 ( 부분 문제의 개수, 분할된 문제의 크기, 분할과정의 복잡도에 따라 결정 )
        - 분할 정복 알고리즘은 재귀를 사용하여 문제를 해결하므로, 재귀 호출의 깊이에 따라 시간 복잡도가 결정된다.
        - 분할된 문제들의 크기가 일정하다면, 재귀 호출의 깊이는 로그 시간 복잡도에 비례.

    *분할된 문제의 개수가 N이라면, 시간 복잡도는 O(N*logN)*

    - 분할된 문제의 개수가 지수적으로 증가하거나 분할된 문제들이 크기가 일정하지 않은 경우, 시간 복잡도가 지수적으로 증가할 수 있음.

    - 병합 정렬
        - 분할과 정복을 모두 사용하여 리스트를 반으로 나누어 각각을 재귀적으로 정렬하고, 두 개 의 부분 리스트를 합쳐 전체 리스트를 정렬하는 방식

        - 동작 과정
            - 1. 분할: 입력 리스트를 반으로 나눈다.
            - 2. 정복: 각각의 부분 리스트를 재귀적으로 병합 정렬한다.
            - 3. 결합: 정렬된 부분 리스트를 합쳐 전체 리스트를 정렬한다.

    - 퀵 정렬
        - 분할과 정복을 사용하여 리스트를 분할하고, 각각을 재귀적으로 정렬한 다음, 전체 리스트를 합치지 않고 원래 위치에 놓여있는 것을 기준으로 정렬 (정렬을 위해 별도의 저장 공간을 필요호 하지 않아 메모리 사용량이 적다.)

        - 동작과정
            - 1. 피벗 선택: 리스트에서 하나의 원소를 기준점으로 선택한다.
            - 2. 분할: 기준점을 기준으로 리스트를 두 개로 분할. 분할된 두 개의 리스트는 각각 기준점보다 작은 값과 큰값으로 이루어짐.
            - 3. 정복: 각각의 부분 리스트를 재귀적으로 퀵 정렬 한다.
            - 4. 결합: 정렬된 부분 리스트를 합쳐 전체 리스트를 정렬한다.

* 스택
    - 데이터를 임시 저장할 때 사용하는 자료구조로, 데이터의 입력과 출력 순서는 후입선출 방식이다.
        - 여기서 후입선출 방식이란? -> 가장 나중에 넣은 데이터를 가장 먼저 꺼낸다는 뜻!

    - 푸시(push): 스택에 데이터를 넣는 작업
    - 팝(pop): 스택에서 데이터를 꺼내는 작업

    - 겹쳐 쌓은 접시처럼 데이터를 넣고 꺼내는 작업을 맨 위부터 수행함.
    - 꼭대기(top): 푸시하고 팝하는 윗부분
    - 바닥(bottom): 아랫부분

    - 스택배열(stk): 푸시한 데이터를 저장하는 스택 본체인 list형 배열. / 인덱스가 0인 원소를 스택의 바닥이라고 함.
        - 가장 먼저 푸시하여 데이터를 저장하는 곳은 stk[0]이다.

    - 스택 크기(capacity): 스택의 최대 크기를 나타내는 int형 정수. 이 값은 배열 stk의 원소 수인 len(stk)와 일치함.

    - 스택 포인터(str): 스택에 쌓여 있는 데이터의 개수를 나타내는 정수값. / 스택이 비어 있으면 ptr의 값은 0이 되고 가득 차 있으면 capacity와 같은 값이 된다.

    - 에외 처리 클래스 Empty
        - pop() 함수 또는 peek() 함수를 호출할 때 스택이 비어 있으면 내보내는 예외 처리.

    - 예외 처리 클래스 Full
        - push() 함수를 호출할 떄 스택이 가득 차 있으면 내보내는 예외 처리이다.

    - 초기화하는 __init__() 함수
        - 스택 배열을 생성하는 등의 준비 작업을 수행. 
            - 작업과정
                - 매개변수 capacity로 전달받은 값을 스택의 크기를 나타내는 필드인 capacity로 복사
                - 원소 수가 capacity이고 모든 원소가 None인 리스트형 stk를 생성
                - 이때 스택이 비어있으므로 스택 포인터 ptr의 값을 0으로 한다.

    - 쌓여있는 데이터 개수를 알아내는 __len__() 함수
        - 스택에 쌓여 있는 데이터 개수를 반환. (스택 포인터 ptr값을 그대로 반환)

    - 스택이 비어 있는지를 판단하는 is_empty() 함수
        - 데이터가 하나도 쌓여 있지 않은 상태, 즉 스택이 비어 있는지를 판단. (비어 있으면 True, 비어있지 않으면 False)

    - 스택이 가득 차 있는지를 판단하는 is_full() 함수
        - 더 이상 데이터를 푸시할 수 없는 상태, 즉 스택이 가득 차 있는지 판단. (가득 차 있으면 True, 가득 차 있지  않으면 False)
        
    - 데이터를 푸시하는 push() 함수
        - 스택에 데이터를 추가한다. (가득 차있을시, FixedStack.Full을 통해 예외 처리 보냄.)
        - 전달받은 value를 배열 원소 stk[ptr]에 저장하고, 스택 포인터 ptr을 1 증가.

    - 데이터를 팝하는 pop() 함수
        - 스택의 꼭대기에서 데이터를 꺼내서 그 값을 반환. (스택이 비어있는 경우, FixedStack.Full을 통해 예외 처리 보냄.)
        - 스택이 비어있지 않을 시, 스택 포인터 ptr의 값을 1 감소시키고, stk[ptr]에 저장된 값을 반환.

    - 데이터를 들여다보는 peek() 함수
        - 스택의 꼭대기 데이터를 들여다 봄. (스택이 비어있는 경우, FixedStack.Full을 통해 예외 처리 보냄.)
        - 스택이 비어있지 않으면 꼭대기 원소 stk[ptr-1]의 값을 반환. 데이터의 입출력이 없으므로 스택 포인터는 변화X

    - 스택의 모든 데이터를 삭제하는 clear() 함수
        - 스택에 쌓여 있는 데이터를 모두 삭제하여 빈 스택을 만듦. 스택 포인터 ptr의 값을 0으로 하면 끝.

    - 데이터를 검색하는 find() 함수
        - 스택 본체의 배열 stk안에 value와 같은 데이터가 포함되어 있는지 확인하고, 포함되어 있다면 배열의 어디에 들어 있는지를 검색.

    - 데이터 개수를 세는 count() 함수
        - 스택에 쌓여 있는 데이터(value)의 개수를 구하여 반환.

    - 데이터가 포함되어 있는지 판단하는 __contains__() 함수
        - 스택에 데이터(value)가 있는지 판단. (있으면 True, 없으면 False를 반환)

    - 스택의 모든 데이터를 출력하는 dump() 함수
        - 스택에 쌓여 있는 ptr개의 모든 데이터를 바닥부터 꼭대기까지 순서대로 출력. (스택이 비어있으면, 비어있다고 출력.ssss)
    

* 큐웹

* 우선순위 큐

* Linked List

* 해시테이블

------------------------------------------------------------
* 문제 풀어보기

* 1920 수 찾기
    - main branch

* 10816	숫자 카드 2
    - [10816..py](10816.py)
    - 시간 초과 문제 발생

* 1654 랜선 자르기
    - [1654.py](1654.py)

* 2805 나무 자르기
    - main branch
------------------------------------------------------------