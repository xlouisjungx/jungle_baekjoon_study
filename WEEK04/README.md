------------------------------------------------------------
# jungle_study
------------------------------------------------------------
### 4주차 공부 README
* 교재에 대한 공부와 공부 키워드에 따른 공부를 작성합니다.
------------------------------------------------------------
## 4주차 범위: 3장. 프로그램의 기계 수준 표현

### 책읽기

            
------------------------------------------------------------
## 4주차 범위: 동적 프로그래밍, 그리디 알고리즘

### 공부 키워드

연습 문제 : [Practice_py](Practice_py)

* 다이나믹 프로그래밍
    - 큰 문제를 작은 문제로 나누어 푸는 방법론.
        - 작은 문제들의 해답을 이용해 큰 문제의 해답을 찾느 과정에서 효율적인 메모리 사용과 계산 속도 향상을 목표로 함.

    - 다이나믹 프로그래밍의 기본 원리(속성)
        - 최적 부분 구조 (Optimal Substructure)
            - 문제를 작은 하위 문제들로 나누고, 이 하위 문제들의 해답을 이용하여 원래 문제의 해답을 도출할 수 있는 속성.
                -  Ex) 피보나치 수열의 경우, F(n) = F(n-1) + F(n-2)와 같이 작은 문제들의 해답을 이용해 큰 문제의 해답을 구할 수 있습니다.

        - 중복되는 부분 문제 (Overlapping Subproblems)
            - 문제를 풀기 위해 동일한 하위 문제를 여러 번 풀어야 하는 경우.
                - Ex) 피보나치 수열에서는 F(n-1)과 F(n-2)를 계산하기 위해 F(n-2)와 F(n-3)을 반복적으로 계산해야 합니다.

    - 다이나믹 프로그래밍의 구현 방식
        - 탑다운(메모이제이션, Memoization) 방식
            - 재귀 함수와 메모이제이션을 이용하여 구현.
            - 이미 계산된 결과를 저장해 두고 필요할 때마다 재사용하여 중복 계산을 방지함.

        - 바텀업(Bottom-Up) 방식
            - 반복문을 이용하여 작은 문제부터 차근차근 해결해 나감.
            - 메모이제이션 없이, 작은 문제의 해답을 순차적으로 계산하여 최종 해답에 도달.

    - 예시 코드
        - 피보나치 수열
            - [ex_Pibo.py](ex_Pibo.py)

        - 최소 동전 거스름돈 문제
            - [find_min_coin.py](find_min_coin.py)

    - 활용
        - 경로 찾기 문제: *미로 문제*나 *최단 경로 문제* 등에서 DP를 활용해, 최적의 경로를 찾을 수 있다.
        - 문자열 처리 문제: *편집 거리 문제*나 *가장 긴 공통 부분 수열 문제* 등에서 DP를 사용하며 효율적으로 문제를 해결할 수 있다.
        - 배낭 문제: *한정된 무게 안에서 최대 가치를 얻는 문제* 등에서 DP를 사용하여 최적의 해답을 도출할 수 있음.

    - 주의사항
        - 1. 문제를 이해하고 작은 문제로 나누기
            - 문제를 작은 단위로 나누고, 이 작은 문제들이 어떻게 큰 문제를 해결하는지 파악해야함.
        - 2. 메모이제이션과 바텀업 방식 선택
            - 문제의 특성과 요구 사항에 따라 메모이제이션(탑다운) 방식이나 바텀업 방식을 선택하여 구현.
        - 3. 적절한 자료 구조 사용
            - DP 테이블으 구현할 때, 문제에 따라 리스트, 딕셔너리 등 적절한 자료 구조를 선택하여 사용.

* 그리디 알고리즘
    - 단순하지만 강력한 문제 해결 방법. 어떠한 문제를 해결할 때 현재 상황에서 가장 최적이라고 생각되는 선택을 반복적으로 하는 방식의 알고리즘. 즉, 각 단계에서 초선의 선택을 함으로써 전체 문제의 최적해를 구하려는 접근법.

        - 선택의 순간에 후속 결과를 고려하지 않고, 국소 최적 (Local Optimal)을 추구. 이러한 특성으로 인해 모든 문제에 적응할 수 있는 것은 아니지만, 특정 조으을 만족하는 문제에서는 매우 효율적으로 작동.

        - *사전에 외우고 있지 않아도 풀 수 있을 가능성이 높은 문제 유형*
            - 최단경로 기반의 알고리즘(다익스트라) 경우도 그리디 기반의 알고리즘이지만 어느정도 개념을 암기를 해야하는 경우도 있다하고 함.

        - 기준에 따라 좋은 것을 선택하는 알고리즘이므로 문제에서 '가장 큰 순서대로', '가장 작은 순서대로'와 같은 기준을 알게 모르게 제시하는 경우! 대체로 이 기준은 정렬 알고리즘을 사해했을 때 만족시킬 수 있으므로 *그리디 알고리즘 문제는 자주 정렬 알고리즘과 짝을 이뤄 출제됨.*

    - 원리
        - 한번 선택한 결과는 음음 선택에 어떠한 영향도 미치치 않아야 한다. 각 단계마다 최선의 선택이 이루어지면 그걸로 끝이므로 이전 결과를 들여다볼 필요가 없으며, 이런 방식으로 최적의 해결책을 찾을 수 있다면 *탐욕 알고리즘*을 사용해서 문제를 풀 수 있다.

        - 탐욕적 선택 속성
            - 한 번 선택한 결과는 다음 선택에 어떠한 영향도 미치지 않아야 한다. 각 단계마다 최선의 선택이 이루어지면 그걸로 끝이므로 이전 결과를 들여다볼 필요가 없으며, 이런 방식으로 최적의 해결책을 찾을 수 있다면 탐욕 알고리즘을 사용해서 문제를 풀 수 있음.

        - 최적 부분 구조
            - 문제의 최적해가 부분 문제들의 최적해로 구도될 수 있음을 의미한다. 이는 동적 계획법과 유사한 개념이지만, 그리디 알고리즘은 부분 문제의 최적해를 재사용하지 않고 각 단계에서 독립적으로 최적 선택을 함. 
            - --> 동적 프로그래밍은 작은 문제가 주어졌을 때 특정 계산법을 사용해서 최적의 정답을 이끌어내는 원리를 큰 문제에서도 활용하는 것이고, 탐욕 알고리즘은 작은 문제든 큰 문제든 항상 일관적으로 '최선의 경우'만을 선택해서 최적의 정답을 이끌어낸다고 이해하면 된다.

    - 그리디 알고리즘의 예제
        - 다양한 문제들에 적용될 수 있지만, *동전 거스름돈 문제, 활동 선택 문제, 허프만 코딩* 등이 대표적.

    - 정당성
        - 그리디 알고리즘이 모든 알고리즘 문제에 적용할 수 있는 것은 아니지만, 탐욕적으로 문제에 접근했을 때 정확한 답을 찾을 수 있다는 보장이 있는 알고리즘 문제라면, 매우 효과적.
        - -> 문제 이이를 위한 최소한의 아이디어를 떠올리고 이것이 정당한지 검토할 수 있어야, 답을 도출할 수 있음.

    - 장점
        - 간단하고 직관적! : 구현이 비교적 쉽고, 문제를 단계별로 접근할 수 있다.
        - 효율적! : 대부분의 경우 시간 복잡도가 낮아 빠르게 결과를 도출할 수 있다.

    - 단점
        - 항상 최적해를 보장하지 않음! : 그리디 선택이 전체 최적해로 이어지지 않는 경우가 있다.
        - 문제에 따라 적용 어려움! : 그리디 선택 속성과 최적 부분 구조를 만족는는 문제가 제한적.

    - 사용할 수 있는 문제 유형
        - 최소/최대 비용 문제: 최소 비용으로 특정 목표를 달성하거나, 최대 이익을 추구할 때.
        - 배낭 문제 (일부, 분수 배낭 문제): 물건을 배낭에 담을 때 가치 대비 무게가 높은 순으로 선택
        - 그래프 알고리즘: 크루스칼의 최소 신장 트리, 다익스트라의 최단 경로 등.

    - 다른 알고리즘과의 차이점
        - 그리디 알고리즘: 현재 단계에서 최적의 선택을 함으로써 전체 문제의 최적해를 추구.
            
        - 동적 계획법: 문제를 작은 부분 문제로 나어 어각 부분 문제의 최적해를 구하고, 이를 조합하여 전체 문제의 최적해를 도출.

            - *적용범위(동적 계획법 > 그리디 알고리즘)*
            - 동적 계획법은 더 일반적으로 적용할 수 있으며, 그리디 알고리즘에서 적도되지 않는 문제에서도 사용할 수 있다.
            - 그리디 알고리즘은 간단하고 빠르기 때문에, 그리디 선택 속성과 최적 부분 구조가 총족되는 경우 더 선호됨.

        - 분할 정복
            - 문제를 여러 부분으로 나누어 해결하는 점에서 유사하지만, 그리디 알고리즘은 각 단계에서 최적 선택을 하는 반면, 분할 정복은 문제를 분할하고 각 분할된 문제를 해결한 후 결합하여 전체 문제를 해결.

    - 실제 응용 사례
        - 네트워크 라우팅: 데이터 패킷을 네트워크 상에서 효율적으로 전달하기 위해 그리디 알고리즘이 사용됨. 최단 경로를 찾는 다익스트라 알고리즘 역시 그리디의 일종이라고 함.

        - 일정 관리: 일정 관리에서 최대한 많은 활동을 선택하거나, 회의실 배정을 최적화하는 문제에 그리디 알고리즘이 적용됨.

        - 허프만 코딩: 데이터 압축에서 허프만 코딩은 그리디 알고리즘을 이용하여 빈도가 높은 문자에 짧은 코드를 할당함으로써 전체 데이터의 크기를 줄임.


* LCS (Longest Common Subsequence)

* Knapsack Problem

* Linked List

* 포인터(pointer), & 연산자와 * 연산자

------------------------------------------------------------

* 기본 알고리즘 틀


------------------------------------------------------------